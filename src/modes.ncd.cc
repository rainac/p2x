// -*- c++ -*- 
// This file has been automatically generated by
// gennc.sh $Id: gennc.xsl 109 2018-10-08 16:10:40Z jwillkomm $
// from definition file xml/modes.ncd.xml. Class mode is false.

#include <string>
#include <cstring>
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include "modes.ncd.enum.hh"
#include "modes.ncd.hh"
    char const *getParserModeName(unsigned long c) {
      switch(c) { 
       case MODE_IGNORE: return "IGNORE";
       case MODE_ITEM: return "ITEM";
       case MODE_UNARY: return "UNARY";
       case MODE_POSTFIX: return "POSTFIX";
       case MODE_BINARY: return "BINARY";
       case MODE_UNARY_BINARY: return "UNARY_BINARY";
       case MODE_LINE_COMMENT: return "LINE_COMMENT";
       case MODE_PAREN: return "PAREN";
       case MODE_PAREN_COMMENT: return "PAREN_COMMENT";
        default: break;
      }
      return "unknown value in enumeration ParserMode";
    }
    char const *getParserModeComment(unsigned long c) {
      switch(c) { 
       case MODE_IGNORE: return "";
       case MODE_ITEM: return "";
       case MODE_UNARY: return "";
       case MODE_POSTFIX: return "";
       case MODE_BINARY: return "";
       case MODE_UNARY_BINARY: return "";
       case MODE_LINE_COMMENT: return "";
       case MODE_PAREN: return "";
       case MODE_PAREN_COMMENT: return "";
        default: break;
      }
      return "unknown value in enumeration ParserMode";
    }
    ParserMode getParserModeValue(char const *name, int *res) {
       if (res) *res = 0;
       if (name == 0 || *name == 0) { return MODE_IGNORE;
       } else if (strcasecmp("IGNORE", name) == 0
          || strcasecmp("MODE_IGNORE", name) == 0) {
          return MODE_IGNORE;
       } else if (strcasecmp("ITEM", name) == 0
          || strcasecmp("MODE_ITEM", name) == 0) {
          return MODE_ITEM;
       } else if (strcasecmp("UNARY", name) == 0
          || strcasecmp("MODE_UNARY", name) == 0) {
          return MODE_UNARY;
       } else if (strcasecmp("POSTFIX", name) == 0
          || strcasecmp("MODE_POSTFIX", name) == 0) {
          return MODE_POSTFIX;
       } else if (strcasecmp("BINARY", name) == 0
          || strcasecmp("MODE_BINARY", name) == 0) {
          return MODE_BINARY;
       } else if (strcasecmp("UNARY_BINARY", name) == 0
          || strcasecmp("MODE_UNARY_BINARY", name) == 0) {
          return MODE_UNARY_BINARY;
       } else if (strcasecmp("LINE_COMMENT", name) == 0
          || strcasecmp("MODE_LINE_COMMENT", name) == 0) {
          return MODE_LINE_COMMENT;
       } else if (strcasecmp("PAREN", name) == 0
          || strcasecmp("MODE_PAREN", name) == 0) {
          return MODE_PAREN;
       } else if (strcasecmp("PAREN_COMMENT", name) == 0
          || strcasecmp("MODE_PAREN_COMMENT", name) == 0) {
          return MODE_PAREN_COMMENT;
       } else {
          if (! res) {
            fprintf(stderr, "error: unknown %s constant named `%s'\n",
              "ParserMode", name);
          } else {
             *res = 1;
          }
          return MODE_IGNORE;
       }
    }
    unsigned long getNumParserMode() {
      return 9;
    }
    ParserMode getParserMode(int which) {
      switch(which) { 
       case 0: return MODE_IGNORE;
       case 1: return MODE_ITEM;
       case 2: return MODE_UNARY;
       case 3: return MODE_POSTFIX;
       case 4: return MODE_BINARY;
       case 5: return MODE_UNARY_BINARY;
       case 6: return MODE_LINE_COMMENT;
       case 7: return MODE_PAREN;
       case 8: return MODE_PAREN_COMMENT;
       default: break;
      }
      fprintf(stderr, "error: ParserMode constant index %d out of range\n",
              which);
      return MODE_IGNORE;
    }
    
