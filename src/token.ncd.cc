// -*- c++ -*- 
// This file has been automatically generated by 
// gennc.sh $Id: gennc.xsl 50 2015-04-08 12:45:49Z jwillkomm $ 
// from definition file xml/token.ncd.xml. Class mode is true.
static char const *getParserTokenName(unsigned long c) {
      switch(c) { 
       case TOKEN_EOF: return "EOF";
       case TOKEN_KEYW_FOR: return "KEYW_FOR";
       case TOKEN_KEYW_IF: return "KEYW_IF";
       case TOKEN_KEYW_WHILE: return "KEYW_WHILE";
       case TOKEN_KEYW_ELSE: return "KEYW_ELSE";
       case TOKEN_KEYW_ELSEIF: return "KEYW_ELSEIF";
       case TOKEN_KEYW_SWITCH: return "KEYW_SWITCH";
       case TOKEN_KEYW_CASE: return "KEYW_CASE";
       case TOKEN_KEYW_OTHERWISE: return "KEYW_OTHERWISE";
       case TOKEN_KEYW_DEFAULT: return "KEYW_DEFAULT";
       case TOKEN_KEYW_RETURN: return "KEYW_RETURN";
       case TOKEN_KEYW_FUNCTION: return "KEYW_FUNCTION";
       case TOKEN_KEYW_BREAK: return "KEYW_BREAK";
       case TOKEN_KEYW_CONTINUE: return "KEYW_CONTINUE";
       case TOKEN_KEYW_GOTO: return "KEYW_GOTO";
       case TOKEN_KEYW_STATIC: return "KEYW_STATIC";
       case TOKEN_KEYW_PUBLIC: return "KEYW_PUBLIC";
       case TOKEN_KEYW_PRIVATE: return "KEYW_PRIVATE";
       case TOKEN_KEYW_REGISTER: return "KEYW_REGISTER";
       case TOKEN_KEYW_AUTO: return "KEYW_AUTO";
       case TOKEN_KEYW_VAR: return "KEYW_VAR";
       case TOKEN_KEYW_CONST: return "KEYW_CONST";
       case TOKEN_KEYW_GLOBAL: return "KEYW_GLOBAL";
       case TOKEN_KEYW_PERSISTENT: return "KEYW_PERSISTENT";
       case TOKEN_KEYW_TRY: return "KEYW_TRY";
       case TOKEN_KEYW_CATCH: return "KEYW_CATCH";
       case TOKEN_KEYW_END: return "KEYW_END";
       case TOKEN_ROOT: return "ROOT";
       case TOKEN_INTEGER: return "INTEGER";
       case TOKEN_FLOAT: return "FLOAT";
       case TOKEN_STRING: return "STRING";
       case TOKEN_IDENTIFIER: return "IDENTIFIER";
       case TOKEN_HASH_COMMENT: return "HASH_COMMENT";
       case TOKEN_CLINE_COMMENT: return "CLINE_COMMENT";
       case TOKEN_C_COMMENT: return "C_COMMENT";
       case TOKEN_L_PAREN: return "L_PAREN";
       case TOKEN_R_PAREN: return "R_PAREN";
       case TOKEN_L_BRACE: return "L_BRACE";
       case TOKEN_R_BRACE: return "R_BRACE";
       case TOKEN_L_BRACKET: return "L_BRACKET";
       case TOKEN_R_BRACKET: return "R_BRACKET";
       case TOKEN_EQUAL: return "EQUAL";
       case TOKEN_LESS: return "LESS";
       case TOKEN_GREATER: return "GREATER";
       case TOKEN_EXCLAM: return "EXCLAM";
       case TOKEN_QUESTION: return "QUESTION";
       case TOKEN_TILDE: return "TILDE";
       case TOKEN_PLUS: return "PLUS";
       case TOKEN_MINUS: return "MINUS";
       case TOKEN_MULT: return "MULT";
       case TOKEN_DIV: return "DIV";
       case TOKEN_BACKSLASH: return "BACKSLASH";
       case TOKEN_MOD: return "MOD";
       case TOKEN_POW: return "POW";
       case TOKEN_COLON: return "COLON";
       case TOKEN_COMMA: return "COMMA";
       case TOKEN_SEMICOLON: return "SEMICOLON";
       case TOKEN_FULL_STOP: return "FULL_STOP";
       case TOKEN_UNDERSCORE: return "UNDERSCORE";
       case TOKEN_DOLLAR: return "DOLLAR";
       case TOKEN_AT: return "AT";
       case TOKEN_AND: return "AND";
       case TOKEN_OR: return "OR";
       case TOKEN_CIRC: return "CIRC";
       case TOKEN_HASH: return "HASH";
       case TOKEN_QUOTE: return "QUOTE";
       case TOKEN_APOS: return "APOS";
       case TOKEN_CRETURN: return "CRETURN";
       case TOKEN_NEWLINE: return "NEWLINE";
       case TOKEN_TAB: return "TAB";
       case TOKEN_SPACE: return "SPACE";
       case TOKEN_JUXTA: return "JUXTA";
       case TOKEN_JUXTA_POST: return "JUXTA_POST";
       case TOKEN_ILLEGAL_CHAR: return "ILLEGAL_CHAR";
       case TOKEN_LEFT_ARROW: return "LEFT_ARROW";
       case TOKEN_RIGHT_ARROW: return "RIGHT_ARROW";
       case TOKEN_DOUBLE_LEFT_ARROW: return "DOUBLE_LEFT_ARROW";
       case TOKEN_DOUBLE_RIGHT_ARROW: return "DOUBLE_RIGHT_ARROW";
       case TOKEN_DOUBLE_AND: return "DOUBLE_AND";
       case TOKEN_DOUBLE_OR: return "DOUBLE_OR";
       case TOKEN_DOUBLE_COLON: return "DOUBLE_COLON";
       case TOKEN_TRIPLE_COLON: return "TRIPLE_COLON";
       case TOKEN_LE: return "LE";
       case TOKEN_GE: return "GE";
       case TOKEN_DOUBLE_L_BRACKET: return "DOUBLE_L_BRACKET";
       case TOKEN_DOUBLE_R_BRACKET: return "DOUBLE_R_BRACKET";
       case TOKEN_DOUBLE_EQUAL: return "DOUBLE_EQUAL";
       case TOKEN_NOT_EQUAL: return "NOT_EQUAL";
       case TOKEN_OPERATOR: return "OPERATOR";
       case TOKEN_MINUS_GREATER: return "MINUS_GREATER";
       case TOKEN_DOUBLE_PLUS: return "DOUBLE_PLUS";
       case TOKEN_DOUBLE_MINUS: return "DOUBLE_MINUS";
       case TOKEN_DOUBLE_LESS: return "DOUBLE_LESS";
       case TOKEN_DOUBLE_GREATER: return "DOUBLE_GREATER";
       case TOKEN_AND_EQUAL: return "AND_EQUAL";
       case TOKEN_OR_EQUAL: return "OR_EQUAL";
       case TOKEN_POW_EQUAL: return "POW_EQUAL";
       case TOKEN_PLUS_EQUAL: return "PLUS_EQUAL";
       case TOKEN_MINUS_EQUAL: return "MINUS_EQUAL";
       case TOKEN_MULT_EQUAL: return "MULT_EQUAL";
       case TOKEN_DIV_EQUAL: return "DIV_EQUAL";
       case TOKEN_MOD_EQUAL: return "MOD_EQUAL";
       case TOKEN_DOUBLE_LESS_EQUAL: return "DOUBLE_LESS_EQUAL";
       case TOKEN_DOUBLE_GREATER_EQUAL: return "DOUBLE_GREATER_EQUAL";
       case TOKEN_IGNORE: return "IGNORE";
       case TOKEN_LAST: return "LAST"; 
        default: break;
      }
      return "unknown value in enumeration ParserToken";
    }
    static char const *getParserTokenComment(unsigned long c) {
      switch(c) { 
       case TOKEN_EOF: return "";
       case TOKEN_KEYW_FOR: return "";
       case TOKEN_KEYW_IF: return "";
       case TOKEN_KEYW_WHILE: return "";
       case TOKEN_KEYW_ELSE: return "";
       case TOKEN_KEYW_ELSEIF: return "";
       case TOKEN_KEYW_SWITCH: return "";
       case TOKEN_KEYW_CASE: return "";
       case TOKEN_KEYW_OTHERWISE: return "";
       case TOKEN_KEYW_DEFAULT: return "";
       case TOKEN_KEYW_RETURN: return "";
       case TOKEN_KEYW_FUNCTION: return "";
       case TOKEN_KEYW_BREAK: return "";
       case TOKEN_KEYW_CONTINUE: return "";
       case TOKEN_KEYW_GOTO: return "";
       case TOKEN_KEYW_STATIC: return "";
       case TOKEN_KEYW_PUBLIC: return "";
       case TOKEN_KEYW_PRIVATE: return "";
       case TOKEN_KEYW_REGISTER: return "";
       case TOKEN_KEYW_AUTO: return "";
       case TOKEN_KEYW_VAR: return "";
       case TOKEN_KEYW_CONST: return "";
       case TOKEN_KEYW_GLOBAL: return "";
       case TOKEN_KEYW_PERSISTENT: return "";
       case TOKEN_KEYW_TRY: return "";
       case TOKEN_KEYW_CATCH: return "";
       case TOKEN_KEYW_END: return "";
       case TOKEN_ROOT: return "";
       case TOKEN_INTEGER: return "";
       case TOKEN_FLOAT: return "";
       case TOKEN_STRING: return "";
       case TOKEN_IDENTIFIER: return "";
       case TOKEN_HASH_COMMENT: return "";
       case TOKEN_CLINE_COMMENT: return "";
       case TOKEN_C_COMMENT: return "";
       case TOKEN_L_PAREN: return "";
       case TOKEN_R_PAREN: return "";
       case TOKEN_L_BRACE: return "";
       case TOKEN_R_BRACE: return "";
       case TOKEN_L_BRACKET: return "";
       case TOKEN_R_BRACKET: return "";
       case TOKEN_EQUAL: return "";
       case TOKEN_LESS: return "";
       case TOKEN_GREATER: return "";
       case TOKEN_EXCLAM: return "";
       case TOKEN_QUESTION: return "";
       case TOKEN_TILDE: return "";
       case TOKEN_PLUS: return "";
       case TOKEN_MINUS: return "";
       case TOKEN_MULT: return "";
       case TOKEN_DIV: return "";
       case TOKEN_BACKSLASH: return "";
       case TOKEN_MOD: return "";
       case TOKEN_POW: return "";
       case TOKEN_COLON: return "";
       case TOKEN_COMMA: return "";
       case TOKEN_SEMICOLON: return "";
       case TOKEN_FULL_STOP: return "";
       case TOKEN_UNDERSCORE: return "";
       case TOKEN_DOLLAR: return "";
       case TOKEN_AT: return "";
       case TOKEN_AND: return "";
       case TOKEN_OR: return "";
       case TOKEN_CIRC: return "";
       case TOKEN_HASH: return "";
       case TOKEN_QUOTE: return "";
       case TOKEN_APOS: return "";
       case TOKEN_CRETURN: return "";
       case TOKEN_NEWLINE: return "";
       case TOKEN_TAB: return "";
       case TOKEN_SPACE: return "";
       case TOKEN_JUXTA: return "";
       case TOKEN_JUXTA_POST: return "";
       case TOKEN_ILLEGAL_CHAR: return "";
       case TOKEN_LEFT_ARROW: return "";
       case TOKEN_RIGHT_ARROW: return "";
       case TOKEN_DOUBLE_LEFT_ARROW: return "";
       case TOKEN_DOUBLE_RIGHT_ARROW: return "";
       case TOKEN_DOUBLE_AND: return "";
       case TOKEN_DOUBLE_OR: return "";
       case TOKEN_DOUBLE_COLON: return "";
       case TOKEN_TRIPLE_COLON: return "";
       case TOKEN_LE: return "";
       case TOKEN_GE: return "";
       case TOKEN_DOUBLE_L_BRACKET: return "";
       case TOKEN_DOUBLE_R_BRACKET: return "";
       case TOKEN_DOUBLE_EQUAL: return "";
       case TOKEN_NOT_EQUAL: return "";
       case TOKEN_OPERATOR: return "";
       case TOKEN_MINUS_GREATER: return "";
       case TOKEN_DOUBLE_PLUS: return "";
       case TOKEN_DOUBLE_MINUS: return "";
       case TOKEN_DOUBLE_LESS: return "";
       case TOKEN_DOUBLE_GREATER: return "";
       case TOKEN_AND_EQUAL: return "";
       case TOKEN_OR_EQUAL: return "";
       case TOKEN_POW_EQUAL: return "";
       case TOKEN_PLUS_EQUAL: return "";
       case TOKEN_MINUS_EQUAL: return "";
       case TOKEN_MULT_EQUAL: return "";
       case TOKEN_DIV_EQUAL: return "";
       case TOKEN_MOD_EQUAL: return "";
       case TOKEN_DOUBLE_LESS_EQUAL: return "";
       case TOKEN_DOUBLE_GREATER_EQUAL: return "";
       case TOKEN_IGNORE: return "";
       case TOKEN_LAST: return ""; 
        default: break;
      }
      return "unknown value in enumeration ParserToken";
    }
    static ParserToken getParserTokenValue(char const *name, int *res) {
       if (res) *res = 0;
       if (name == 0 || *name == 0) { return TOKEN_EOF; 
       } else if (strcasecmp("EOF", name) == 0
          || strcasecmp("TOKEN_EOF", name) == 0) {
          return TOKEN_EOF; 
       } else if (strcasecmp("KEYW_FOR", name) == 0
          || strcasecmp("TOKEN_KEYW_FOR", name) == 0) {
          return TOKEN_KEYW_FOR; 
       } else if (strcasecmp("KEYW_IF", name) == 0
          || strcasecmp("TOKEN_KEYW_IF", name) == 0) {
          return TOKEN_KEYW_IF; 
       } else if (strcasecmp("KEYW_WHILE", name) == 0
          || strcasecmp("TOKEN_KEYW_WHILE", name) == 0) {
          return TOKEN_KEYW_WHILE; 
       } else if (strcasecmp("KEYW_ELSE", name) == 0
          || strcasecmp("TOKEN_KEYW_ELSE", name) == 0) {
          return TOKEN_KEYW_ELSE; 
       } else if (strcasecmp("KEYW_ELSEIF", name) == 0
          || strcasecmp("TOKEN_KEYW_ELSEIF", name) == 0) {
          return TOKEN_KEYW_ELSEIF; 
       } else if (strcasecmp("KEYW_SWITCH", name) == 0
          || strcasecmp("TOKEN_KEYW_SWITCH", name) == 0) {
          return TOKEN_KEYW_SWITCH; 
       } else if (strcasecmp("KEYW_CASE", name) == 0
          || strcasecmp("TOKEN_KEYW_CASE", name) == 0) {
          return TOKEN_KEYW_CASE; 
       } else if (strcasecmp("KEYW_OTHERWISE", name) == 0
          || strcasecmp("TOKEN_KEYW_OTHERWISE", name) == 0) {
          return TOKEN_KEYW_OTHERWISE; 
       } else if (strcasecmp("KEYW_DEFAULT", name) == 0
          || strcasecmp("TOKEN_KEYW_DEFAULT", name) == 0) {
          return TOKEN_KEYW_DEFAULT; 
       } else if (strcasecmp("KEYW_RETURN", name) == 0
          || strcasecmp("TOKEN_KEYW_RETURN", name) == 0) {
          return TOKEN_KEYW_RETURN; 
       } else if (strcasecmp("KEYW_FUNCTION", name) == 0
          || strcasecmp("TOKEN_KEYW_FUNCTION", name) == 0) {
          return TOKEN_KEYW_FUNCTION; 
       } else if (strcasecmp("KEYW_BREAK", name) == 0
          || strcasecmp("TOKEN_KEYW_BREAK", name) == 0) {
          return TOKEN_KEYW_BREAK; 
       } else if (strcasecmp("KEYW_CONTINUE", name) == 0
          || strcasecmp("TOKEN_KEYW_CONTINUE", name) == 0) {
          return TOKEN_KEYW_CONTINUE; 
       } else if (strcasecmp("KEYW_GOTO", name) == 0
          || strcasecmp("TOKEN_KEYW_GOTO", name) == 0) {
          return TOKEN_KEYW_GOTO; 
       } else if (strcasecmp("KEYW_STATIC", name) == 0
          || strcasecmp("TOKEN_KEYW_STATIC", name) == 0) {
          return TOKEN_KEYW_STATIC; 
       } else if (strcasecmp("KEYW_PUBLIC", name) == 0
          || strcasecmp("TOKEN_KEYW_PUBLIC", name) == 0) {
          return TOKEN_KEYW_PUBLIC; 
       } else if (strcasecmp("KEYW_PRIVATE", name) == 0
          || strcasecmp("TOKEN_KEYW_PRIVATE", name) == 0) {
          return TOKEN_KEYW_PRIVATE; 
       } else if (strcasecmp("KEYW_REGISTER", name) == 0
          || strcasecmp("TOKEN_KEYW_REGISTER", name) == 0) {
          return TOKEN_KEYW_REGISTER; 
       } else if (strcasecmp("KEYW_AUTO", name) == 0
          || strcasecmp("TOKEN_KEYW_AUTO", name) == 0) {
          return TOKEN_KEYW_AUTO; 
       } else if (strcasecmp("KEYW_VAR", name) == 0
          || strcasecmp("TOKEN_KEYW_VAR", name) == 0) {
          return TOKEN_KEYW_VAR; 
       } else if (strcasecmp("KEYW_CONST", name) == 0
          || strcasecmp("TOKEN_KEYW_CONST", name) == 0) {
          return TOKEN_KEYW_CONST; 
       } else if (strcasecmp("KEYW_GLOBAL", name) == 0
          || strcasecmp("TOKEN_KEYW_GLOBAL", name) == 0) {
          return TOKEN_KEYW_GLOBAL; 
       } else if (strcasecmp("KEYW_PERSISTENT", name) == 0
          || strcasecmp("TOKEN_KEYW_PERSISTENT", name) == 0) {
          return TOKEN_KEYW_PERSISTENT; 
       } else if (strcasecmp("KEYW_TRY", name) == 0
          || strcasecmp("TOKEN_KEYW_TRY", name) == 0) {
          return TOKEN_KEYW_TRY; 
       } else if (strcasecmp("KEYW_CATCH", name) == 0
          || strcasecmp("TOKEN_KEYW_CATCH", name) == 0) {
          return TOKEN_KEYW_CATCH; 
       } else if (strcasecmp("KEYW_END", name) == 0
          || strcasecmp("TOKEN_KEYW_END", name) == 0) {
          return TOKEN_KEYW_END; 
       } else if (strcasecmp("ROOT", name) == 0
          || strcasecmp("TOKEN_ROOT", name) == 0) {
          return TOKEN_ROOT; 
       } else if (strcasecmp("INTEGER", name) == 0
          || strcasecmp("TOKEN_INTEGER", name) == 0) {
          return TOKEN_INTEGER; 
       } else if (strcasecmp("FLOAT", name) == 0
          || strcasecmp("TOKEN_FLOAT", name) == 0) {
          return TOKEN_FLOAT; 
       } else if (strcasecmp("STRING", name) == 0
          || strcasecmp("TOKEN_STRING", name) == 0) {
          return TOKEN_STRING; 
       } else if (strcasecmp("IDENTIFIER", name) == 0
          || strcasecmp("TOKEN_IDENTIFIER", name) == 0) {
          return TOKEN_IDENTIFIER; 
       } else if (strcasecmp("HASH_COMMENT", name) == 0
          || strcasecmp("TOKEN_HASH_COMMENT", name) == 0) {
          return TOKEN_HASH_COMMENT; 
       } else if (strcasecmp("CLINE_COMMENT", name) == 0
          || strcasecmp("TOKEN_CLINE_COMMENT", name) == 0) {
          return TOKEN_CLINE_COMMENT; 
       } else if (strcasecmp("C_COMMENT", name) == 0
          || strcasecmp("TOKEN_C_COMMENT", name) == 0) {
          return TOKEN_C_COMMENT; 
       } else if (strcasecmp("L_PAREN", name) == 0
          || strcasecmp("TOKEN_L_PAREN", name) == 0) {
          return TOKEN_L_PAREN; 
       } else if (strcasecmp("R_PAREN", name) == 0
          || strcasecmp("TOKEN_R_PAREN", name) == 0) {
          return TOKEN_R_PAREN; 
       } else if (strcasecmp("L_BRACE", name) == 0
          || strcasecmp("TOKEN_L_BRACE", name) == 0) {
          return TOKEN_L_BRACE; 
       } else if (strcasecmp("R_BRACE", name) == 0
          || strcasecmp("TOKEN_R_BRACE", name) == 0) {
          return TOKEN_R_BRACE; 
       } else if (strcasecmp("L_BRACKET", name) == 0
          || strcasecmp("TOKEN_L_BRACKET", name) == 0) {
          return TOKEN_L_BRACKET; 
       } else if (strcasecmp("R_BRACKET", name) == 0
          || strcasecmp("TOKEN_R_BRACKET", name) == 0) {
          return TOKEN_R_BRACKET; 
       } else if (strcasecmp("EQUAL", name) == 0
          || strcasecmp("TOKEN_EQUAL", name) == 0) {
          return TOKEN_EQUAL; 
       } else if (strcasecmp("LESS", name) == 0
          || strcasecmp("TOKEN_LESS", name) == 0) {
          return TOKEN_LESS; 
       } else if (strcasecmp("GREATER", name) == 0
          || strcasecmp("TOKEN_GREATER", name) == 0) {
          return TOKEN_GREATER; 
       } else if (strcasecmp("EXCLAM", name) == 0
          || strcasecmp("TOKEN_EXCLAM", name) == 0) {
          return TOKEN_EXCLAM; 
       } else if (strcasecmp("QUESTION", name) == 0
          || strcasecmp("TOKEN_QUESTION", name) == 0) {
          return TOKEN_QUESTION; 
       } else if (strcasecmp("TILDE", name) == 0
          || strcasecmp("TOKEN_TILDE", name) == 0) {
          return TOKEN_TILDE; 
       } else if (strcasecmp("PLUS", name) == 0
          || strcasecmp("TOKEN_PLUS", name) == 0) {
          return TOKEN_PLUS; 
       } else if (strcasecmp("MINUS", name) == 0
          || strcasecmp("TOKEN_MINUS", name) == 0) {
          return TOKEN_MINUS; 
       } else if (strcasecmp("MULT", name) == 0
          || strcasecmp("TOKEN_MULT", name) == 0) {
          return TOKEN_MULT; 
       } else if (strcasecmp("DIV", name) == 0
          || strcasecmp("TOKEN_DIV", name) == 0) {
          return TOKEN_DIV; 
       } else if (strcasecmp("BACKSLASH", name) == 0
          || strcasecmp("TOKEN_BACKSLASH", name) == 0) {
          return TOKEN_BACKSLASH; 
       } else if (strcasecmp("MOD", name) == 0
          || strcasecmp("TOKEN_MOD", name) == 0) {
          return TOKEN_MOD; 
       } else if (strcasecmp("POW", name) == 0
          || strcasecmp("TOKEN_POW", name) == 0) {
          return TOKEN_POW; 
       } else if (strcasecmp("COLON", name) == 0
          || strcasecmp("TOKEN_COLON", name) == 0) {
          return TOKEN_COLON; 
       } else if (strcasecmp("COMMA", name) == 0
          || strcasecmp("TOKEN_COMMA", name) == 0) {
          return TOKEN_COMMA; 
       } else if (strcasecmp("SEMICOLON", name) == 0
          || strcasecmp("TOKEN_SEMICOLON", name) == 0) {
          return TOKEN_SEMICOLON; 
       } else if (strcasecmp("FULL_STOP", name) == 0
          || strcasecmp("TOKEN_FULL_STOP", name) == 0) {
          return TOKEN_FULL_STOP; 
       } else if (strcasecmp("UNDERSCORE", name) == 0
          || strcasecmp("TOKEN_UNDERSCORE", name) == 0) {
          return TOKEN_UNDERSCORE; 
       } else if (strcasecmp("DOLLAR", name) == 0
          || strcasecmp("TOKEN_DOLLAR", name) == 0) {
          return TOKEN_DOLLAR; 
       } else if (strcasecmp("AT", name) == 0
          || strcasecmp("TOKEN_AT", name) == 0) {
          return TOKEN_AT; 
       } else if (strcasecmp("AND", name) == 0
          || strcasecmp("TOKEN_AND", name) == 0) {
          return TOKEN_AND; 
       } else if (strcasecmp("OR", name) == 0
          || strcasecmp("TOKEN_OR", name) == 0) {
          return TOKEN_OR; 
       } else if (strcasecmp("CIRC", name) == 0
          || strcasecmp("TOKEN_CIRC", name) == 0) {
          return TOKEN_CIRC; 
       } else if (strcasecmp("HASH", name) == 0
          || strcasecmp("TOKEN_HASH", name) == 0) {
          return TOKEN_HASH; 
       } else if (strcasecmp("QUOTE", name) == 0
          || strcasecmp("TOKEN_QUOTE", name) == 0) {
          return TOKEN_QUOTE; 
       } else if (strcasecmp("APOS", name) == 0
          || strcasecmp("TOKEN_APOS", name) == 0) {
          return TOKEN_APOS; 
       } else if (strcasecmp("CRETURN", name) == 0
          || strcasecmp("TOKEN_CRETURN", name) == 0) {
          return TOKEN_CRETURN; 
       } else if (strcasecmp("NEWLINE", name) == 0
          || strcasecmp("TOKEN_NEWLINE", name) == 0) {
          return TOKEN_NEWLINE; 
       } else if (strcasecmp("TAB", name) == 0
          || strcasecmp("TOKEN_TAB", name) == 0) {
          return TOKEN_TAB; 
       } else if (strcasecmp("SPACE", name) == 0
          || strcasecmp("TOKEN_SPACE", name) == 0) {
          return TOKEN_SPACE; 
       } else if (strcasecmp("JUXTA", name) == 0
          || strcasecmp("TOKEN_JUXTA", name) == 0) {
          return TOKEN_JUXTA; 
       } else if (strcasecmp("JUXTA_POST", name) == 0
          || strcasecmp("TOKEN_JUXTA_POST", name) == 0) {
          return TOKEN_JUXTA_POST; 
       } else if (strcasecmp("ILLEGAL_CHAR", name) == 0
          || strcasecmp("TOKEN_ILLEGAL_CHAR", name) == 0) {
          return TOKEN_ILLEGAL_CHAR; 
       } else if (strcasecmp("LEFT_ARROW", name) == 0
          || strcasecmp("TOKEN_LEFT_ARROW", name) == 0) {
          return TOKEN_LEFT_ARROW; 
       } else if (strcasecmp("RIGHT_ARROW", name) == 0
          || strcasecmp("TOKEN_RIGHT_ARROW", name) == 0) {
          return TOKEN_RIGHT_ARROW; 
       } else if (strcasecmp("DOUBLE_LEFT_ARROW", name) == 0
          || strcasecmp("TOKEN_DOUBLE_LEFT_ARROW", name) == 0) {
          return TOKEN_DOUBLE_LEFT_ARROW; 
       } else if (strcasecmp("DOUBLE_RIGHT_ARROW", name) == 0
          || strcasecmp("TOKEN_DOUBLE_RIGHT_ARROW", name) == 0) {
          return TOKEN_DOUBLE_RIGHT_ARROW; 
       } else if (strcasecmp("DOUBLE_AND", name) == 0
          || strcasecmp("TOKEN_DOUBLE_AND", name) == 0) {
          return TOKEN_DOUBLE_AND; 
       } else if (strcasecmp("DOUBLE_OR", name) == 0
          || strcasecmp("TOKEN_DOUBLE_OR", name) == 0) {
          return TOKEN_DOUBLE_OR; 
       } else if (strcasecmp("DOUBLE_COLON", name) == 0
          || strcasecmp("TOKEN_DOUBLE_COLON", name) == 0) {
          return TOKEN_DOUBLE_COLON; 
       } else if (strcasecmp("TRIPLE_COLON", name) == 0
          || strcasecmp("TOKEN_TRIPLE_COLON", name) == 0) {
          return TOKEN_TRIPLE_COLON; 
       } else if (strcasecmp("LE", name) == 0
          || strcasecmp("TOKEN_LE", name) == 0) {
          return TOKEN_LE; 
       } else if (strcasecmp("GE", name) == 0
          || strcasecmp("TOKEN_GE", name) == 0) {
          return TOKEN_GE; 
       } else if (strcasecmp("DOUBLE_L_BRACKET", name) == 0
          || strcasecmp("TOKEN_DOUBLE_L_BRACKET", name) == 0) {
          return TOKEN_DOUBLE_L_BRACKET; 
       } else if (strcasecmp("DOUBLE_R_BRACKET", name) == 0
          || strcasecmp("TOKEN_DOUBLE_R_BRACKET", name) == 0) {
          return TOKEN_DOUBLE_R_BRACKET; 
       } else if (strcasecmp("DOUBLE_EQUAL", name) == 0
          || strcasecmp("TOKEN_DOUBLE_EQUAL", name) == 0) {
          return TOKEN_DOUBLE_EQUAL; 
       } else if (strcasecmp("NOT_EQUAL", name) == 0
          || strcasecmp("TOKEN_NOT_EQUAL", name) == 0) {
          return TOKEN_NOT_EQUAL; 
       } else if (strcasecmp("OPERATOR", name) == 0
          || strcasecmp("TOKEN_OPERATOR", name) == 0) {
          return TOKEN_OPERATOR; 
       } else if (strcasecmp("MINUS_GREATER", name) == 0
          || strcasecmp("TOKEN_MINUS_GREATER", name) == 0) {
          return TOKEN_MINUS_GREATER; 
       } else if (strcasecmp("DOUBLE_PLUS", name) == 0
          || strcasecmp("TOKEN_DOUBLE_PLUS", name) == 0) {
          return TOKEN_DOUBLE_PLUS; 
       } else if (strcasecmp("DOUBLE_MINUS", name) == 0
          || strcasecmp("TOKEN_DOUBLE_MINUS", name) == 0) {
          return TOKEN_DOUBLE_MINUS; 
       } else if (strcasecmp("DOUBLE_LESS", name) == 0
          || strcasecmp("TOKEN_DOUBLE_LESS", name) == 0) {
          return TOKEN_DOUBLE_LESS; 
       } else if (strcasecmp("DOUBLE_GREATER", name) == 0
          || strcasecmp("TOKEN_DOUBLE_GREATER", name) == 0) {
          return TOKEN_DOUBLE_GREATER; 
       } else if (strcasecmp("AND_EQUAL", name) == 0
          || strcasecmp("TOKEN_AND_EQUAL", name) == 0) {
          return TOKEN_AND_EQUAL; 
       } else if (strcasecmp("OR_EQUAL", name) == 0
          || strcasecmp("TOKEN_OR_EQUAL", name) == 0) {
          return TOKEN_OR_EQUAL; 
       } else if (strcasecmp("POW_EQUAL", name) == 0
          || strcasecmp("TOKEN_POW_EQUAL", name) == 0) {
          return TOKEN_POW_EQUAL; 
       } else if (strcasecmp("PLUS_EQUAL", name) == 0
          || strcasecmp("TOKEN_PLUS_EQUAL", name) == 0) {
          return TOKEN_PLUS_EQUAL; 
       } else if (strcasecmp("MINUS_EQUAL", name) == 0
          || strcasecmp("TOKEN_MINUS_EQUAL", name) == 0) {
          return TOKEN_MINUS_EQUAL; 
       } else if (strcasecmp("MULT_EQUAL", name) == 0
          || strcasecmp("TOKEN_MULT_EQUAL", name) == 0) {
          return TOKEN_MULT_EQUAL; 
       } else if (strcasecmp("DIV_EQUAL", name) == 0
          || strcasecmp("TOKEN_DIV_EQUAL", name) == 0) {
          return TOKEN_DIV_EQUAL; 
       } else if (strcasecmp("MOD_EQUAL", name) == 0
          || strcasecmp("TOKEN_MOD_EQUAL", name) == 0) {
          return TOKEN_MOD_EQUAL; 
       } else if (strcasecmp("DOUBLE_LESS_EQUAL", name) == 0
          || strcasecmp("TOKEN_DOUBLE_LESS_EQUAL", name) == 0) {
          return TOKEN_DOUBLE_LESS_EQUAL; 
       } else if (strcasecmp("DOUBLE_GREATER_EQUAL", name) == 0
          || strcasecmp("TOKEN_DOUBLE_GREATER_EQUAL", name) == 0) {
          return TOKEN_DOUBLE_GREATER_EQUAL; 
       } else if (strcasecmp("IGNORE", name) == 0
          || strcasecmp("TOKEN_IGNORE", name) == 0) {
          return TOKEN_IGNORE; 
       } else if (strcasecmp("LAST", name) == 0
          || strcasecmp("TOKEN_LAST", name) == 0) {
          return TOKEN_LAST;  
       } else {
          if (! res) {
            fprintf(stderr, "error: unknown %s constant named `%s'\n",
              "ParserToken", name);
          } else {
             *res = 1;
          }
          return TOKEN_EOF;
       }
    }
    static unsigned long getNumParserToken() {
      return 106;
    }
    static ParserToken getParserToken(int which) {
      switch(which) { 
       case 0: return TOKEN_EOF;
       case 1: return TOKEN_KEYW_FOR;
       case 2: return TOKEN_KEYW_IF;
       case 3: return TOKEN_KEYW_WHILE;
       case 4: return TOKEN_KEYW_ELSE;
       case 5: return TOKEN_KEYW_ELSEIF;
       case 6: return TOKEN_KEYW_SWITCH;
       case 7: return TOKEN_KEYW_CASE;
       case 8: return TOKEN_KEYW_OTHERWISE;
       case 9: return TOKEN_KEYW_DEFAULT;
       case 10: return TOKEN_KEYW_RETURN;
       case 11: return TOKEN_KEYW_FUNCTION;
       case 12: return TOKEN_KEYW_BREAK;
       case 13: return TOKEN_KEYW_CONTINUE;
       case 14: return TOKEN_KEYW_GOTO;
       case 15: return TOKEN_KEYW_STATIC;
       case 16: return TOKEN_KEYW_PUBLIC;
       case 17: return TOKEN_KEYW_PRIVATE;
       case 18: return TOKEN_KEYW_REGISTER;
       case 19: return TOKEN_KEYW_AUTO;
       case 20: return TOKEN_KEYW_VAR;
       case 21: return TOKEN_KEYW_CONST;
       case 22: return TOKEN_KEYW_GLOBAL;
       case 23: return TOKEN_KEYW_PERSISTENT;
       case 24: return TOKEN_KEYW_TRY;
       case 25: return TOKEN_KEYW_CATCH;
       case 26: return TOKEN_KEYW_END;
       case 27: return TOKEN_ROOT;
       case 28: return TOKEN_INTEGER;
       case 29: return TOKEN_FLOAT;
       case 30: return TOKEN_STRING;
       case 31: return TOKEN_IDENTIFIER;
       case 32: return TOKEN_HASH_COMMENT;
       case 33: return TOKEN_CLINE_COMMENT;
       case 34: return TOKEN_C_COMMENT;
       case 35: return TOKEN_L_PAREN;
       case 36: return TOKEN_R_PAREN;
       case 37: return TOKEN_L_BRACE;
       case 38: return TOKEN_R_BRACE;
       case 39: return TOKEN_L_BRACKET;
       case 40: return TOKEN_R_BRACKET;
       case 41: return TOKEN_EQUAL;
       case 42: return TOKEN_LESS;
       case 43: return TOKEN_GREATER;
       case 44: return TOKEN_EXCLAM;
       case 45: return TOKEN_QUESTION;
       case 46: return TOKEN_TILDE;
       case 47: return TOKEN_PLUS;
       case 48: return TOKEN_MINUS;
       case 49: return TOKEN_MULT;
       case 50: return TOKEN_DIV;
       case 51: return TOKEN_BACKSLASH;
       case 52: return TOKEN_MOD;
       case 53: return TOKEN_POW;
       case 54: return TOKEN_COLON;
       case 55: return TOKEN_COMMA;
       case 56: return TOKEN_SEMICOLON;
       case 57: return TOKEN_FULL_STOP;
       case 58: return TOKEN_UNDERSCORE;
       case 59: return TOKEN_DOLLAR;
       case 60: return TOKEN_AT;
       case 61: return TOKEN_AND;
       case 62: return TOKEN_OR;
       case 63: return TOKEN_CIRC;
       case 64: return TOKEN_HASH;
       case 65: return TOKEN_QUOTE;
       case 66: return TOKEN_APOS;
       case 67: return TOKEN_CRETURN;
       case 68: return TOKEN_NEWLINE;
       case 69: return TOKEN_TAB;
       case 70: return TOKEN_SPACE;
       case 71: return TOKEN_JUXTA;
       case 72: return TOKEN_JUXTA_POST;
       case 73: return TOKEN_ILLEGAL_CHAR;
       case 74: return TOKEN_LEFT_ARROW;
       case 75: return TOKEN_RIGHT_ARROW;
       case 76: return TOKEN_DOUBLE_LEFT_ARROW;
       case 77: return TOKEN_DOUBLE_RIGHT_ARROW;
       case 78: return TOKEN_DOUBLE_AND;
       case 79: return TOKEN_DOUBLE_OR;
       case 80: return TOKEN_DOUBLE_COLON;
       case 81: return TOKEN_TRIPLE_COLON;
       case 82: return TOKEN_LE;
       case 83: return TOKEN_GE;
       case 84: return TOKEN_DOUBLE_L_BRACKET;
       case 85: return TOKEN_DOUBLE_R_BRACKET;
       case 86: return TOKEN_DOUBLE_EQUAL;
       case 87: return TOKEN_NOT_EQUAL;
       case 88: return TOKEN_OPERATOR;
       case 89: return TOKEN_MINUS_GREATER;
       case 90: return TOKEN_DOUBLE_PLUS;
       case 91: return TOKEN_DOUBLE_MINUS;
       case 92: return TOKEN_DOUBLE_LESS;
       case 93: return TOKEN_DOUBLE_GREATER;
       case 94: return TOKEN_AND_EQUAL;
       case 95: return TOKEN_OR_EQUAL;
       case 96: return TOKEN_POW_EQUAL;
       case 97: return TOKEN_PLUS_EQUAL;
       case 98: return TOKEN_MINUS_EQUAL;
       case 99: return TOKEN_MULT_EQUAL;
       case 100: return TOKEN_DIV_EQUAL;
       case 101: return TOKEN_MOD_EQUAL;
       case 102: return TOKEN_DOUBLE_LESS_EQUAL;
       case 103: return TOKEN_DOUBLE_GREATER_EQUAL;
       case 104: return TOKEN_IGNORE;
       case 105: return TOKEN_LAST; 
       default: break;
      }
      fprintf(stderr, "error: ParserToken constant index %d out of range\n",
              which);
      return TOKEN_EOF;
    }
    
    inline static ParserToken getParserTokenValue(std::string const &t, int *res = 0) {
       return getParserTokenValue(t.c_str(), res);
    }
    
