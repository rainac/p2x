// -*- c++ -*- 
// This file has been automatically generated by
// gennc.sh 47
// from definition file xml/token.ncd.xml.

#define ParserToken__numItems 121
#define ParserToken__prefix "TOKEN_"
typedef ParserToken ParserToken_T;


#define ParserToken__prefixLen 6


typedef uint8_t ParserToken_IndexT;



static int ParserToken__compnames(const void *m1, const void *m2) {
  char const * const * mi1 = (char const * const *) m1;
  char const * const * mi2 = (char const * const *) m2;
  return strcasecmp(*mi1, *mi2);
}

static constexpr  char const* const ParserToken__names[ParserToken__numItems + 1] = {
  "AND", "AND_EQUAL", "APOS", "AT", "BACKSLASH", "BACKSLASH_EQUAL", "CIRC", "CLINE_COMMENT", "COLON", "COMMA",
  "CRETURN", "C_COMMENT", "C_COMMENT_END", "C_COMMENT_START", "DIV", "DIV_EQUAL", "DOLLAR", "DOTAPOS", "DOTBACKSLASH", "DOTDIV",
  "DOTMULT", "DOTPOW", "DOT_BACKSLASH_EQUAL", "DOT_DIV_EQUAL", "DOT_MULT_EQUAL", "DOT_POW_EQUAL", "DOUBLE_AND", "DOUBLE_COLON", "DOUBLE_DIV", "DOUBLE_EQUAL",
  "DOUBLE_GREATER", "DOUBLE_GREATER_EQUAL", "DOUBLE_LEFT_ARROW", "DOUBLE_LESS", "DOUBLE_LESS_EQUAL", "DOUBLE_L_BRACKET", "DOUBLE_MINUS", "DOUBLE_OR", "DOUBLE_PLUS", "DOUBLE_RIGHT_ARROW",
  "DOUBLE_R_BRACKET", "EOF", "EQUAL", "EXCLAM", "FLOAT", "FULL_STOP", "GE", "GREATER", "HASH", "HASH_COMMENT",
  "IDENTIFIER", "IGNORE", "ILLEGAL_CHAR", "INTEGER", "JUXTA", "JUXTA_POST", "KEYW_AUTO", "KEYW_BREAK", "KEYW_CASE", "KEYW_CATCH",
  "KEYW_CONST", "KEYW_CONTINUE", "KEYW_DEFAULT", "KEYW_ELSE", "KEYW_ELSEIF", "KEYW_END", "KEYW_FOR", "KEYW_FUNCTION", "KEYW_GLOBAL", "KEYW_GOTO",
  "KEYW_IF", "KEYW_OTHERWISE", "KEYW_PERSISTENT", "KEYW_PRIVATE", "KEYW_PUBLIC", "KEYW_REGISTER", "KEYW_RETURN", "KEYW_STATIC", "KEYW_SWITCH", "KEYW_TRY",
  "KEYW_VAR", "KEYW_WHILE", "LAST", "LE", "LEFT_ARROW", "LESS", "L_BRACE", "L_BRACKET", "L_PAREN", "MINUS",
  "MINUS_EQUAL", "MINUS_GREATER", "MOD", "MOD_EQUAL", "MULT", "MULT_EQUAL", "NEWLINE", "NOT_EQUAL", "OPERATOR", "OR",
  "OR_EQUAL", "PLUS", "PLUS_EQUAL", "POW", "POW_EQUAL", "QUESTION", "QUOTE", "RIGHT_ARROW", "ROOT", "R_BRACE",
  "R_BRACKET", "R_PAREN", "SEMICOLON", "SPACE", "STRING", "TAB", "TILDE", "TILDE_EQUAL", "TRIPLE_COLON", "TRIPLE_DOT",
  "UNDERSCORE"
};

static constexpr ParserToken_IndexT const ParserToken__indexNames[ParserToken__numItems] = {
  61, 94, 66, 60, 51, 110, 63, 33, 54, 55,
  67, 34, 118, 117, 50, 100, 59, 108, 106, 105,
  104, 107, 114, 113, 112, 115, 78, 80, 116, 86,
  93, 103, 76, 92, 102, 84, 91, 79, 90, 77,
  85, 0, 41, 44, 29, 57, 83, 43, 64, 32,
  31, 119, 73, 28, 71, 72, 19, 12, 7, 25,
  21, 13, 9, 4, 5, 26, 1, 11, 22, 14,
  2, 8, 23, 17, 16, 18, 10, 15, 6, 24,
  20, 3, 120, 82, 74, 42, 37, 39, 35, 48,
  98, 89, 52, 101, 49, 99, 68, 87, 88, 62,
  95, 47, 97, 53, 96, 45, 65, 75, 27, 38,
  40, 36, 56, 70, 30, 69, 46, 111, 81, 109,
  58
};

static constexpr ParserToken_IndexT const ParserToken__invNames[ParserToken__numItems + 1] = {
  41, 66, 70, 81, 63, 64, 78, 58, 71, 62,
  76, 67, 57, 61, 69, 77, 74, 73, 75, 56,
  80, 60, 68, 72, 79, 59, 65, 108, 53, 44,
  114, 50, 49, 7, 11, 88, 111, 86, 109, 87,
  110, 42, 85, 47, 43, 105, 116, 101, 89, 94,
  14, 4, 92, 103, 8, 9, 112, 45, 120, 16,
  3, 0, 99, 6, 48, 106, 2, 10, 96, 115,
  113, 54, 55, 52, 84, 107, 32, 39, 26, 37,
  27, 118, 83, 46, 35, 40, 29, 97, 98, 91,
  38, 36, 33, 30, 1, 100, 104, 102, 90, 95,
  15, 93, 34, 31, 20, 19, 18, 21, 17, 119,
  5, 117, 24, 23, 22, 25, 28, 13, 12, 51,
  82, ParserToken__numItems
};

static size_t ParserToken_getLength() {
  return ParserToken__numItems;
}

static char const* ParserToken_getPrefix() {
  return ParserToken__prefix;
}

static ParserToken_T ParserToken_getIthCode(int i) {
  if (i >= 0 && i < ParserToken__numItems) {

    return (ParserToken_T) i;

  }
  return (ParserToken_T) -1;
}

static char const* ParserToken_getIthName(int i) {
  if (i >= 0 && i < ParserToken__numItems) {
    return ParserToken__names[ParserToken__invNames[i]];
  }
  return 0;
}

static char const* ParserToken_getIthComment(int) {

  return 0;
}

static int ParserToken_isCode(ParserToken_T n) {
  return ParserToken_getName(n) != 0;
}

static ParserToken_IndexT ParserToken__getCodeIndex(ParserToken_T code) {
  if ((unsigned) code < ParserToken__numItems) return code;
  return ParserToken__numItems;
}

static char const *ParserToken_getName(ParserToken_T code) {
  return ParserToken__names[ParserToken__invNames[ParserToken__getCodeIndex(code)]];
}

static ParserToken_T ParserToken_getCode(char const *name, int* res) {
  char const* const* found = (char const* const*)  bsearch(&name, ParserToken__names, ParserToken__numItems, sizeof(char const*), &ParserToken__compnames);
  if (res) *res = found == 0;
  if (found) {
    ParserToken_IndexT n = found - ParserToken__names;
    return (ParserToken_T) ParserToken__indexNames[n];
  }
  return (ParserToken_T) -1;
}

static ParserToken_T ParserToken_getCodeFullName(char const *name, int* res) {
  return ParserToken_getCode(name + ParserToken__prefixLen, res);
}

static char const *ParserToken_getComment(ParserToken_T) {

  return 0;

}


static char const *getParserTokenName(ParserToken_T c) {
  return Token::ParserToken_getName(c);
}

static char const *getParserTokenComment(ParserToken_T c) {
  return Token::ParserToken_getComment(c);
}

static ParserToken_T getParserTokenValue(char const *name, int *res) {
   if (strncasecmp(name, ParserToken__prefix, ParserToken__prefixLen) == 0) {
     return Token::ParserToken_getCodeFullName(name, res);
   } else {
     return Token::ParserToken_getCode(name, res);
   }
}

static size_t getNumParserToken() {
  return Token::ParserToken_getLength();
}

static ParserToken_T getParserToken(int which) {
  return Token::ParserToken_getIthCode(which);
}

inline static ParserToken getParserTokenValue(std::string const &t, int *res = 0) {
   return getParserTokenValue(t.c_str(), res);
}

